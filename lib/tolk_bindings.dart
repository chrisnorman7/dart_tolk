// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for the Tolk screen reader library
class DartTolk {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  DartTolk(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  DartTolk.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  late final ffi.Pointer<uintptr_t> ___security_cookie =
      _lookup<uintptr_t>('__security_cookie');

  int get __security_cookie => ___security_cookie.value;

  set __security_cookie(int value) => ___security_cookie.value = value;

  /// Name:         Tolk_Load
  /// Description:  Initializes Tolk by loading and initializing the screen reader drivers and setting the current screen reader driver, provided at least one of the supported screen readers is active. Also initializes COM if it has not already been initialized on the calling thread. Calling this function more than once will only initialize COM. You should call this function before using the functions below. Use Tolk_IsLoaded to determine if Tolk has been initialized.
  /// Parameters:   None.
  /// Returns:      None.
  void Tolk_Load() {
    return _Tolk_Load();
  }

  late final _Tolk_LoadPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Tolk_Load');
  late final _Tolk_Load = _Tolk_LoadPtr.asFunction<void Function()>();

  /// Name:         Tolk_IsLoaded
  /// Description:  Tests if Tolk has been initialized.
  /// Parameters:   None.
  /// Returns:      true if Tolk has been initialized, false otherwise.
  bool Tolk_IsLoaded() {
    return _Tolk_IsLoaded();
  }

  late final _Tolk_IsLoadedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Tolk_IsLoaded');
  late final _Tolk_IsLoaded = _Tolk_IsLoadedPtr.asFunction<bool Function()>();

  /// Name:         Tolk_Unload
  /// Description:  Finalizes Tolk by finalizing and unloading the screen reader drivers and clearing the current screen reader driver, provided one was set. Also uninitializes COM on the calling thread. Calling this function more than once will only uninitialize COM. You should not use the functions below if this function has been called.
  /// Parameters:   None.
  /// Returns:      None.
  void Tolk_Unload() {
    return _Tolk_Unload();
  }

  late final _Tolk_UnloadPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Tolk_Unload');
  late final _Tolk_Unload = _Tolk_UnloadPtr.asFunction<void Function()>();

  /// Name:         Tolk_TrySAPI
  /// Description:  Sets if Microsoft Speech API (SAPI) should be used in the screen reader auto-detection process. The default is not to include SAPI. The SAPI driver will use the system default synthesizer, voice and soundcard. This function triggers the screen reader detection process if needed. For best performance, you should call this function before calling Tolk_Load.
  /// Parameters:   trySAPI: whether or not to include SAPI in auto-detection.
  /// Returns:      None.
  void Tolk_TrySAPI(
    bool trySAPI,
  ) {
    return _Tolk_TrySAPI(
      trySAPI,
    );
  }

  late final _Tolk_TrySAPIPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>('Tolk_TrySAPI');
  late final _Tolk_TrySAPI = _Tolk_TrySAPIPtr.asFunction<void Function(bool)>();

  /// Name:         Tolk_PreferSAPI
  /// Description:  If auto-detection for SAPI has been turned on through Tolk_TrySAPI, sets if SAPI should be placed first (true) or last (false) in the screen reader detection list. Putting it last is the default and is good for using SAPI as a fallback option. Putting it first is good for ensuring SAPI is used even when a screen reader is running, but keep in mind screen readers will still be tried if SAPI is unavailable. This function triggers the screen reader detection process if needed. For best performance, you should call this function before calling Tolk_Load.
  /// Parameters:   preferSAPI: whether or not to prefer SAPI over screen reader drivers in auto-detection.
  /// Returns:      None.
  void Tolk_PreferSAPI(
    bool preferSAPI,
  ) {
    return _Tolk_PreferSAPI(
      preferSAPI,
    );
  }

  late final _Tolk_PreferSAPIPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'Tolk_PreferSAPI');
  late final _Tolk_PreferSAPI =
      _Tolk_PreferSAPIPtr.asFunction<void Function(bool)>();

  /// Name:         Tolk_DetectScreenReader
  /// Description:  Returns the common name for the currently active screen reader driver, if one is set. If none is set, tries to detect the currently active screen reader before looking up the name. If no screen reader is active, NULL is returned. Note that the drivers hard-code the common name, it is not requested from the screen reader itself. You should call Tolk_Load once before using this function.
  /// Parameters:   None.
  /// Returns:      A Unicode string representation of the common name on success, NULL otherwise.
  ffi.Pointer<ffi.WChar> Tolk_DetectScreenReader() {
    return _Tolk_DetectScreenReader();
  }

  late final _Tolk_DetectScreenReaderPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.WChar> Function()>>(
          'Tolk_DetectScreenReader');
  late final _Tolk_DetectScreenReader = _Tolk_DetectScreenReaderPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function()>();

  /// Name:         Tolk_HasSpeech
  /// Description:  Tests if the current screen reader driver supports speech output, if one is set. If none is set, tries to detect the currently active screen reader before testing for speech support. You should call Tolk_Load once before using this function.
  /// Parameters:   None.
  /// Returns:      true if the current screen reader driver supports speech, false otherwise.
  bool Tolk_HasSpeech() {
    return _Tolk_HasSpeech();
  }

  late final _Tolk_HasSpeechPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Tolk_HasSpeech');
  late final _Tolk_HasSpeech = _Tolk_HasSpeechPtr.asFunction<bool Function()>();

  /// Name:         Tolk_HasBraille
  /// Description:  Tests if the current screen reader driver supports braille output, if one is set. If none is set, tries to detect the currently active screen reader before testing for braille support. You should call Tolk_Load once before using this function.
  /// Parameters:   None.
  /// Returns:      true if the current screen reader driver supports braille, false otherwise.
  bool Tolk_HasBraille() {
    return _Tolk_HasBraille();
  }

  late final _Tolk_HasBraillePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Tolk_HasBraille');
  late final _Tolk_HasBraille =
      _Tolk_HasBraillePtr.asFunction<bool Function()>();

  bool Tolk_Output(
    ffi.Pointer<ffi.WChar> str,
    bool interrupt,
  ) {
    return _Tolk_Output(
      str,
      interrupt,
    );
  }

  late final _Tolk_OutputPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ffi.WChar>, ffi.Bool)>>('Tolk_Output');
  late final _Tolk_Output =
      _Tolk_OutputPtr.asFunction<bool Function(ffi.Pointer<ffi.WChar>, bool)>();

  bool Tolk_Speak(
    ffi.Pointer<ffi.WChar> str,
    bool interrupt,
  ) {
    return _Tolk_Speak(
      str,
      interrupt,
    );
  }

  late final _Tolk_SpeakPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ffi.WChar>, ffi.Bool)>>('Tolk_Speak');
  late final _Tolk_Speak =
      _Tolk_SpeakPtr.asFunction<bool Function(ffi.Pointer<ffi.WChar>, bool)>();

  /// Name:         Tolk_Braille
  /// Description:  Brailles text through the current screen reader driver, if one is set and supports braille output. If none is set or if it encountered an error, tries to detect the currently active screen reader before brailling the given text. Use this function only if you specifically need to braille text through the current screen reader without also speaking it. Not all screen reader drivers may support this functionality. Therefore, use Tolk_Output whenever possible. You should call Tolk_Load once before using this function.
  /// Parameters:   str: text to braille.
  /// Returns:      true on success, false otherwise.
  bool Tolk_Braille(
    ffi.Pointer<ffi.WChar> str,
  ) {
    return _Tolk_Braille(
      str,
    );
  }

  late final _Tolk_BraillePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.WChar>)>>(
          'Tolk_Braille');
  late final _Tolk_Braille =
      _Tolk_BraillePtr.asFunction<bool Function(ffi.Pointer<ffi.WChar>)>();

  /// Name:         Tolk_IsSpeaking
  /// Description:  Tests if the screen reader associated with the current screen reader driver is speaking, if one is set and supports querying for status information. If none is set, tries to detect the currently active screen reader before testing if it is speaking. You should call Tolk_Load once before using this function.
  /// Parameters:   None.
  /// Returns:      true if text is being spoken by the screen reader, false otherwise.
  bool Tolk_IsSpeaking() {
    return _Tolk_IsSpeaking();
  }

  late final _Tolk_IsSpeakingPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Tolk_IsSpeaking');
  late final _Tolk_IsSpeaking =
      _Tolk_IsSpeakingPtr.asFunction<bool Function()>();

  /// Name:         Tolk_Silence
  /// Description:  Silences the screen reader associated with the current screen reader driver, if one is set and supports speech output. If none is set or if it encountered an error, tries to detect the currently active screen reader before silencing it. You should call Tolk_Load once before using this function.
  /// Parameters:   None.
  /// Returns:      true on success, false otherwise.
  bool Tolk_Silence() {
    return _Tolk_Silence();
  }

  late final _Tolk_SilencePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Tolk_Silence');
  late final _Tolk_Silence = _Tolk_SilencePtr.asFunction<bool Function()>();
}

typedef uintptr_t = ffi.UnsignedLongLong;

class __crt_locale_data_public extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedShort> _locale_pctype;

  @ffi.Int()
  external int _locale_mb_cur_max;

  @ffi.UnsignedInt()
  external int _locale_lc_codepage;
}

class __crt_locale_pointers extends ffi.Struct {
  external ffi.Pointer<__crt_locale_data> locinfo;

  external ffi.Pointer<__crt_multibyte_data> mbcinfo;
}

class __crt_locale_data extends ffi.Opaque {}

class __crt_multibyte_data extends ffi.Opaque {}

class _Mbstatet extends ffi.Struct {
  @ffi.UnsignedLong()
  external int _Wchar;

  @ffi.UnsignedShort()
  external int _Byte;

  @ffi.UnsignedShort()
  external int _State;
}

class _wfinddata32_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int attrib;

  @__time32_t()
  external int time_create;

  @__time32_t()
  external int time_access;

  @__time32_t()
  external int time_write;

  @_fsize_t()
  external int size;

  @ffi.Array.multi([260])
  external ffi.Array<ffi.WChar> name;
}

typedef __time32_t = ffi.Long;
typedef _fsize_t = ffi.UnsignedLong;

class _wfinddata32i64_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int attrib;

  @__time32_t()
  external int time_create;

  @__time32_t()
  external int time_access;

  @__time32_t()
  external int time_write;

  @ffi.LongLong()
  external int size;

  @ffi.Array.multi([260])
  external ffi.Array<ffi.WChar> name;
}

class _wfinddata64i32_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int attrib;

  @__time64_t()
  external int time_create;

  @__time64_t()
  external int time_access;

  @__time64_t()
  external int time_write;

  @_fsize_t()
  external int size;

  @ffi.Array.multi([260])
  external ffi.Array<ffi.WChar> name;
}

typedef __time64_t = ffi.LongLong;

class _wfinddata64_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int attrib;

  @__time64_t()
  external int time_create;

  @__time64_t()
  external int time_access;

  @__time64_t()
  external int time_write;

  @ffi.LongLong()
  external int size;

  @ffi.Array.multi([260])
  external ffi.Array<ffi.WChar> name;
}

class _iobuf extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _Placeholder;
}

class tm extends ffi.Struct {
  @ffi.Int()
  external int tm_sec;

  @ffi.Int()
  external int tm_min;

  @ffi.Int()
  external int tm_hour;

  @ffi.Int()
  external int tm_mday;

  @ffi.Int()
  external int tm_mon;

  @ffi.Int()
  external int tm_year;

  @ffi.Int()
  external int tm_wday;

  @ffi.Int()
  external int tm_yday;

  @ffi.Int()
  external int tm_isdst;
}

class _stat32 extends ffi.Struct {
  @_dev_t()
  external int st_dev;

  @_ino_t()
  external int st_ino;

  @ffi.UnsignedShort()
  external int st_mode;

  @ffi.Short()
  external int st_nlink;

  @ffi.Short()
  external int st_uid;

  @ffi.Short()
  external int st_gid;

  @_dev_t()
  external int st_rdev;

  @_off_t()
  external int st_size;

  @__time32_t()
  external int st_atime;

  @__time32_t()
  external int st_mtime;

  @__time32_t()
  external int st_ctime;
}

typedef _dev_t = ffi.UnsignedInt;
typedef _ino_t = ffi.UnsignedShort;
typedef _off_t = ffi.Long;

class _stat32i64 extends ffi.Struct {
  @_dev_t()
  external int st_dev;

  @_ino_t()
  external int st_ino;

  @ffi.UnsignedShort()
  external int st_mode;

  @ffi.Short()
  external int st_nlink;

  @ffi.Short()
  external int st_uid;

  @ffi.Short()
  external int st_gid;

  @_dev_t()
  external int st_rdev;

  @ffi.LongLong()
  external int st_size;

  @__time32_t()
  external int st_atime;

  @__time32_t()
  external int st_mtime;

  @__time32_t()
  external int st_ctime;
}

class _stat64i32 extends ffi.Struct {
  @_dev_t()
  external int st_dev;

  @_ino_t()
  external int st_ino;

  @ffi.UnsignedShort()
  external int st_mode;

  @ffi.Short()
  external int st_nlink;

  @ffi.Short()
  external int st_uid;

  @ffi.Short()
  external int st_gid;

  @_dev_t()
  external int st_rdev;

  @_off_t()
  external int st_size;

  @__time64_t()
  external int st_atime;

  @__time64_t()
  external int st_mtime;

  @__time64_t()
  external int st_ctime;
}

class _stat64 extends ffi.Struct {
  @_dev_t()
  external int st_dev;

  @_ino_t()
  external int st_ino;

  @ffi.UnsignedShort()
  external int st_mode;

  @ffi.Short()
  external int st_nlink;

  @ffi.Short()
  external int st_uid;

  @ffi.Short()
  external int st_gid;

  @_dev_t()
  external int st_rdev;

  @ffi.LongLong()
  external int st_size;

  @__time64_t()
  external int st_atime;

  @__time64_t()
  external int st_mtime;

  @__time64_t()
  external int st_ctime;
}

class stat extends ffi.Struct {
  @_dev_t()
  external int st_dev;

  @_ino_t()
  external int st_ino;

  @ffi.UnsignedShort()
  external int st_mode;

  @ffi.Short()
  external int st_nlink;

  @ffi.Short()
  external int st_uid;

  @ffi.Short()
  external int st_gid;

  @_dev_t()
  external int st_rdev;

  @_off_t()
  external int st_size;

  @time_t()
  external int st_atime;

  @time_t()
  external int st_mtime;

  @time_t()
  external int st_ctime;
}

typedef time_t = __time64_t;

const int false1 = 0;

const int true1 = 1;

const int __null = 0;

const int _WCHAR_T_DEFINED = 1;

const int TOLK_FILEVERSION = 1;

const String TOLK_FILEVERSION_STR = '1.0.0.0';

const int TOLK_PRODUCTVERSION = 1;

const String TOLK_PRODUCTVERSION_STR = '1.0';
